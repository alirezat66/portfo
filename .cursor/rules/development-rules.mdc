---
description: This is rules of development structure that you should consider.


# ğŸ—ï¸ Flutter Enterprise Architecture Guide

## ğŸ“ Core Architecture Principles

### MVVM Pattern Implementation
- **View**: UI components (Pages, Widgets) - Only display logic
- **ViewModel**: Cubit/Bloc from `flutter_bloc` - State management and UI logic and usecases
- **Model**: Data layer (Repositories) - implementation and abstraction

### Feature-First Structure
```
lib/
â”œâ”€â”€ core/                           # Shared utilities and infrastructure
â”‚   â”œâ”€â”€ data/                      # Generic data utilities (Result<T>, etc.)
â”‚   â”œâ”€â”€ di/                        # Dependency injection setup
â”‚   â”œâ”€â”€ network/                   # HTTP client and network error handling
â”‚   â”œâ”€â”€ storage/                   # Local storage abstractions
â”‚   â””â”€â”€ validation/                # Form validation framework
â”œâ”€â”€ features/                      # All business features
â”‚   â””â”€â”€ {feature_name}/
â”‚       â”œâ”€â”€ {feature_name}_di.dart # Feature-specific DI registration
â”‚       â”œâ”€â”€ view-model
            â””â”€â”€ usecases/ 
            â””â”€â”€ bloc/                  # State management
â”‚       â”‚       â”œâ”€â”€ {feature}_cubit.dart
â”‚       â”‚       â””â”€â”€ {feature}_state.dart
â”‚       â”œâ”€â”€ model/                 # Data layer
â”‚       â”‚   â”œâ”€â”€ data/              # DTOs and request/response models
â”‚       â”‚   â”œâ”€â”€ repositories/      # Data access abstractions & implementations
â”‚       â”‚            # Business logic operations
â”‚       â””â”€â”€ view/                  # UI layer
â”‚           â”œâ”€â”€ {feature}_page.dart
            â”œâ”€â”€ views/
â”‚           â””â”€â”€ widgets/           # Feature-specific UI components
â”œâ”€â”€ widgets/                       # Shared/global UI components
â”œâ”€â”€ main.dart
â”œâ”€â”€ router.dart                    # App navigation
â””â”€â”€ theme.dart                     # UI theming
```

## ğŸ§° Required Dependencies & Tooling

### Core Dependencies
```yaml
dependencies:
  flutter_bloc: ^8.1.3
  get_it: ^7.6.4
  equatable: ^2.0.5
  json_annotation: ^4.8.1
  
dev_dependencies:
  freezed: ^2.4.6
  json_serializable: ^6.7.1
  build_runner: ^2.4.7
  mockito: ^5.4.2
  bloc_test: ^9.1.5
```

## ğŸ“ File Organization Rules

### Naming Conventions
- **Files**: snake_case (e.g., `user_profile_cubit.dart`)
- **Classes**: PascalCase (e.g., `UserProfileCubit`)
- **Parameters**: camelCase (e.g., `firstName`)
- **Constants**: SCREAMING_SNAKE_CASE
- **Folders**: snake_case

### File Separation Principles
- **Single Responsibility**: Each file should contain only one main concept
- **No God Files**: Split large files by responsibility
- **Abstraction Naming**: Don't prefix interfaces with "I" (use `NetworkService`, not `INetworkService`)

### Model Layer Structure
```
model/
â”œâ”€â”€ data/                          # Data Transfer Objects
â”‚   â”œâ”€â”€ {entity}.dart             # Main entity with freezed
â”‚   â”œâ”€â”€ {entity}.g.dart           # Generated JSON serialization
â”‚   â”œâ”€â”€ create_{entity}_request.dart
â”‚   â”œâ”€â”€ update_{entity}_request.dart
â”‚   â””â”€â”€ delete_{entity}_response.dart
â”œâ”€â”€ repositories/                  # Data access layer
â”‚   â”œâ”€â”€ {entity}_repository.dart   # Abstract repository
â”‚   â””â”€â”€ {entity}_repository_impl.dart # Implementation
â””â”€â”€ usecases/                     # Business logic
    â”œâ”€â”€ get_{entities}_usecase.dart
    â”œâ”€â”€ get_{entity}_by_id_usecase.dart
    â”œâ”€â”€ create_{entity}_usecase.dart
    â”œâ”€â”€ update_{entity}_usecase.dart
    â””â”€â”€ delete_{entity}_usecase.dart
```

## ğŸ¯ State Management Standards

### Cubit Implementation
```dart
// Use Cubit by default, Bloc only when streams/operators needed
class FeatureCubit extends Cubit<FeatureState> {
  final UseCase _useCase;
  
  FeatureCubit(Usecase this.useCase) : _useCase = useCase, super(const FeatureState.initial());
  
  for more than 1 object then 
  FeatureCubit({required UseCase this.useCase, UseCase2 this.useCase2}) : _useCase = useCase, _useCase2 = ueeCase2
  
  // Methods for state changes only
  // Complex logic delegated to UseCases
}
```

### State Definition
```dart
// Use Equatable, NOT Freezed for states except when using sealed is more easier
// when we want just return a value as state it is not necessary to have a separate class for state too. you can directly use type as state.
class FeatureState extends Equatable {
  final bool isLoading;
  final List<Entity> entities;
  final String? error;
  
  const FeatureState({
    this.isLoading = false,
    this.entities = const [],
    this.error,
  });
  
  @override
  List<Object?> get props => [isLoading, entities, error];
  
  FeatureState copyWith({...}) => FeatureState(...);
}
```

## ğŸ—ï¸ Data Layer Patterns

### Result Wrapper
```dart
// Always wrap repository responses in Result<T>
sealed class Result<T> {
  const Result();

  R when<R>(R Function(T value) onSuccess, R Function(Object error) onFailure);
  bool get isSuccess;
  T? get valueOrNull;
  Object? get errorOrNull;

  Result<R> map<R>(R Function(T value) mapper) => switch (this) {
    Success<T>(:final value) => Success<R>(mapper(value)),
    Failure<T>(:final error) => Failure<R>(error),
  };

  Result<R> flatMap<R>(Result<R> Function(T value) mapper) => switch (this) {
    Success<T>(:final value) => mapper(value),
    Failure<T>(:final error) => Failure<R>(error),
  };
}

final class Success<T> extends Result<T> {
  const Success(this.value);
  final T value;

  @override
  R when<R>(R Function(T) onSuccess, R Function(Object) onFailure) =>
      onSuccess(value);

  @override
  bool get isSuccess => true;

  @override
  T? get valueOrNull => value;

  @override
  Object? get errorOrNull => null;

  @override
  String toString() => 'Success($value)';
}

final class Failure<T> extends Result<T> {
  const Failure(this.error);
  final Object error;

  @override
  R when<R>(R Function(T) onSuccess, R Function(Object) onFailure) =>
      onFailure(error);

  @override
  bool get isSuccess => false;

  @override
  T? get valueOrNull => null;

  @override
  Object? get errorOrNull => error;

  @override
  String toString() => 'Failure($error)';
}

```

### Repository Pattern
```dart
// Abstract repository
abstract class EntityRepository {
  Future<Result<List<Entity>>> getEntities();
  Future<Result<Entity>> getEntityById(String id);
  Future<Result<Entity>> createEntity(CreateEntityRequest request);
  Future<Result<Entity>> updateEntity(String id, UpdateEntityRequest request);
  Future<Result<void>> deleteEntity(String id);
}

// Implementation
class EntityRepositoryImpl implements EntityRepository {
  final NetworkService _networkService;
  
  EntityRepositoryImpl(this._networkService);
  
  @override
  Future<Result<List<Entity>>> getEntities() async {
    try {
      final response = await _networkService.get('/entities');
      final entities = (response.data as List)
          .map((json) => Entity.fromJson(json))
          .toList();
      return Success(entities);
    } catch (e) {
      return Failure(e.toString());
    }
  }
}
```

### UseCase Pattern
```dart
class GetEntitiesUseCase {
  final EntityRepository _repository;
  
  GetEntitiesUseCase(this._repository);
  
  Future<Result<List<Entity>>> call() async {
    return await _repository.getEntities();
  }
}
```

## ğŸ“Š Data Model Standards

### Use JsonSerializable (Preferred) or Freezed (Alternative)
```dart
// With JsonSerializable
@JsonSerializable()
class Entity extends Equatable {
  final String id;
  final String name;
  final DateTime createdAt;
  
  const Entity({
    required this.id,
    required this.name,
    required this.createdAt,
  });
  
  factory Entity.fromJson(Map<String, dynamic> json) => _$EntityFromJson(json);
  Map<String, dynamic> toJson() => _$EntityToJson(this);
  
  @override
  List<Object> get props => [id, name, createdAt];
}
```

## ğŸ”— Dependency Injection

### Service Locator Setup
```dart
// core/di/service_locator.dart
final getIt = GetIt.instance;

void setupServiceLocator() {
  // Core services
  getIt.registerLazySingleton<NetworkService>(() => HttpNetworkService());
  
  // Feature-specific registration
  setupAuthDI();
  setupCategoriesDI();
}

// features/feature/feature_di.dart
void setupFeatureDI() {
  // Repositories
  getIt.registerLazySingleton<FeatureRepository>(
    () => FeatureRepositoryImpl(getIt<NetworkService>()),
  );
  
  // Use Cases
  getIt.registerLazySingleton(() => GetEntitiesUseCase(getIt()));
  
  // Cubits (Factory for multiple instances)
  getIt.registerFactory(() => FeatureCubit(getIt()));
}
```

## ğŸ¨ UI Architecture

### Atomic Design Pattern


### View Layer Rules
- **No Business Logic**: Views only handle presentation
- **BlocBuilder/BlocListener**: Use appropriate bloc widgets
- **Atomic Components**: Break down complex UIs into reusable pieces
- **Responsive Design**: Handle different screen sizes

## ğŸ§ª Testing Standards

### Test Structure
```
test/
â”œâ”€â”€ features/
â”‚   â””â”€â”€ {feature}/
â”‚       â”œâ”€â”€ bloc/
â”‚       â”‚   â”œâ”€â”€ {feature}_cubit_test.dart
â”‚       â”‚   â””â”€â”€ {feature}_cubit_test.mocks.dart
â”‚       â””â”€â”€ model/
â”‚           â”œâ”€â”€ repositories/
â”‚           â”‚   â”œâ”€â”€ {feature}_repository_impl_test.dart
â”‚           â”‚   â””â”€â”€ {feature}_repository_impl_test.mocks.dart
â”‚           â””â”€â”€ usecases/
â”‚               â”œâ”€â”€ {usecase}_test.dart
â”‚               â””â”€â”€ {usecase}_test.mocks.dart
â””â”€â”€ core/
    â””â”€â”€ network/
        â””â”€â”€ network_service_test.dart
```

### Testing Tools & Patterns
- **Mock Generation**: Use `@GenerateMocks` with mockito
- **Cubit Testing**: Use `bloc_test` package
- **Test Structure**: Arrange, Act, Assert pattern
- **Coverage**: Aim for high coverage on business logic
- **Widget Tests**: Always skip widget tests in development (focus on unit and integration tests)

## ğŸš« Architecture Violations to Avoid

### Forbidden Patterns
- âŒ Business logic in UI widgets
- âŒ Direct API calls from Cubits
- âŒ Using Freezed for Cubit states
- âŒ Layer-first folder structure
- âŒ God classes or files
- âŒ Mixed annotation libraries (stick to one: JsonSerializable OR Freezed)
- âŒ Creating unnecessary abstractions
- âŒ Manual mock creation (use code generation)
- âŒ Widget tests (always skip widget tests in development)
- âŒ Should not use a usecase inside another use case
- âŒ Should not use a repository inside another repository
- âŒ Should not use a cubit inside another cubit

### Required Patterns
- âœ… Repository pattern for data access
- âœ… UseCase pattern for complex business logic
- âœ… Result wrapper for error handling
- âœ… Dependency injection for all dependencies
- âœ… Cubit for state management (Bloc only when needed)
- âœ… Feature-first folder organization
- âœ… Atomic design for UI components

## ğŸ”„ Code Generation Commands

```bash
# Generate JSON serialization
dart run build_runner build --delete-conflicting-outputs

# Generate mocks for testing
dart run build_runner build --delete-conflicting-outputs

# Watch mode for development
dart run build_runner watch --delete-conflicting-outputs
```

---


### ğŸš« Anti-Patterns to Avoid

- âŒ Embedding business logic inside UI (e.g., calling `cubit.someMethod()` inside `build`)
- âŒ Accessing Bloc/Cubit directly in deep nested widgets
- âŒ Deep widget trees in `*_page.dart` â€” extract into views
- âŒ Creating unnecessary atom/molecule folders just to match theory
- âŒ Rewriting reusable widgets for each feature (reuse via `core/widgets`)
- âŒ Using `Freezed` for Cubit states (use `Equatable` instead)
- âŒ Manual Cubit or Repository instantiation (use DI)

---

This structure enables:

- **Consistency** across all features
- **High reusability** via core widgets
- **Clear separation** of layout (views) and composition (widgets)
- **Clean testability** at every layer

Use this UI pattern as a strict convention for all current and future Flutter projects.

globs:
all projects
alwaysApply: true
---
