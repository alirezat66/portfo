---
description: This is rules of development structure that you should consider.


# 🏗️ Flutter Enterprise Architecture Guide

## 📐 Core Architecture Principles

### MVVM Pattern Implementation
- **View**: UI components (Pages, Widgets) - Only display logic
- **ViewModel**: Cubit/Bloc from `flutter_bloc` - State management and UI logic and usecases
- **Model**: Data layer (Repositories) - implementation and abstraction

### Feature-First Structure
```
lib/
├── core/                           # Shared utilities and infrastructure
│   ├── data/                      # Generic data utilities (Result<T>, etc.)
│   ├── di/                        # Dependency injection setup
│   ├── network/                   # HTTP client and network error handling
│   ├── storage/                   # Local storage abstractions
│   └── validation/                # Form validation framework
├── features/                      # All business features
│   └── {feature_name}/
│       ├── {feature_name}_di.dart # Feature-specific DI registration
│       ├── view-model
            └── usecases/ 
            └── bloc/                  # State management
│       │       ├── {feature}_cubit.dart
│       │       └── {feature}_state.dart
│       ├── model/                 # Data layer
│       │   ├── data/              # DTOs and request/response models
│       │   ├── repositories/      # Data access abstractions & implementations
│       │            # Business logic operations
│       └── view/                  # UI layer
│           ├── {feature}_page.dart
            ├── views/
│           └── widgets/           # Feature-specific UI components
├── widgets/                       # Shared/global UI components
├── main.dart
├── router.dart                    # App navigation
└── theme.dart                     # UI theming
```

## 🧰 Required Dependencies & Tooling

### Core Dependencies
```yaml
dependencies:
  flutter_bloc: ^8.1.3
  get_it: ^7.6.4
  equatable: ^2.0.5
  json_annotation: ^4.8.1
  
dev_dependencies:
  freezed: ^2.4.6
  json_serializable: ^6.7.1
  build_runner: ^2.4.7
  mockito: ^5.4.2
  bloc_test: ^9.1.5
```

## 📁 File Organization Rules

### Naming Conventions
- **Files**: snake_case (e.g., `user_profile_cubit.dart`)
- **Classes**: PascalCase (e.g., `UserProfileCubit`)
- **Parameters**: camelCase (e.g., `firstName`)
- **Constants**: SCREAMING_SNAKE_CASE
- **Folders**: snake_case

### File Separation Principles
- **Single Responsibility**: Each file should contain only one main concept
- **No God Files**: Split large files by responsibility
- **Abstraction Naming**: Don't prefix interfaces with "I" (use `NetworkService`, not `INetworkService`)

### Model Layer Structure
```
model/
├── data/                          # Data Transfer Objects
│   ├── {entity}.dart             # Main entity with freezed
│   ├── {entity}.g.dart           # Generated JSON serialization
│   ├── create_{entity}_request.dart
│   ├── update_{entity}_request.dart
│   └── delete_{entity}_response.dart
├── repositories/                  # Data access layer
│   ├── {entity}_repository.dart   # Abstract repository
│   └── {entity}_repository_impl.dart # Implementation
└── usecases/                     # Business logic
    ├── get_{entities}_usecase.dart
    ├── get_{entity}_by_id_usecase.dart
    ├── create_{entity}_usecase.dart
    ├── update_{entity}_usecase.dart
    └── delete_{entity}_usecase.dart
```

## 🎯 State Management Standards

### Cubit Implementation
```dart
// Use Cubit by default, Bloc only when streams/operators needed
class FeatureCubit extends Cubit<FeatureState> {
  final UseCase _useCase;
  
  FeatureCubit(Usecase this.useCase) : _useCase = useCase, super(const FeatureState.initial());
  
  for more than 1 object then 
  FeatureCubit({required UseCase this.useCase, UseCase2 this.useCase2}) : _useCase = useCase, _useCase2 = ueeCase2
  
  // Methods for state changes only
  // Complex logic delegated to UseCases
}
```

### State Definition
```dart
// Use Equatable, NOT Freezed for states except when using sealed is more easier
// when we want just return a value as state it is not necessary to have a separate class for state too. you can directly use type as state.
class FeatureState extends Equatable {
  final bool isLoading;
  final List<Entity> entities;
  final String? error;
  
  const FeatureState({
    this.isLoading = false,
    this.entities = const [],
    this.error,
  });
  
  @override
  List<Object?> get props => [isLoading, entities, error];
  
  FeatureState copyWith({...}) => FeatureState(...);
}
```

## 🏗️ Data Layer Patterns

### Result Wrapper
```dart
// Always wrap repository responses in Result<T>
sealed class Result<T> {
  const Result();

  R when<R>(R Function(T value) onSuccess, R Function(Object error) onFailure);
  bool get isSuccess;
  T? get valueOrNull;
  Object? get errorOrNull;

  Result<R> map<R>(R Function(T value) mapper) => switch (this) {
    Success<T>(:final value) => Success<R>(mapper(value)),
    Failure<T>(:final error) => Failure<R>(error),
  };

  Result<R> flatMap<R>(Result<R> Function(T value) mapper) => switch (this) {
    Success<T>(:final value) => mapper(value),
    Failure<T>(:final error) => Failure<R>(error),
  };
}

final class Success<T> extends Result<T> {
  const Success(this.value);
  final T value;

  @override
  R when<R>(R Function(T) onSuccess, R Function(Object) onFailure) =>
      onSuccess(value);

  @override
  bool get isSuccess => true;

  @override
  T? get valueOrNull => value;

  @override
  Object? get errorOrNull => null;

  @override
  String toString() => 'Success($value)';
}

final class Failure<T> extends Result<T> {
  const Failure(this.error);
  final Object error;

  @override
  R when<R>(R Function(T) onSuccess, R Function(Object) onFailure) =>
      onFailure(error);

  @override
  bool get isSuccess => false;

  @override
  T? get valueOrNull => null;

  @override
  Object? get errorOrNull => error;

  @override
  String toString() => 'Failure($error)';
}

```

### Repository Pattern
```dart
// Abstract repository
abstract class EntityRepository {
  Future<Result<List<Entity>>> getEntities();
  Future<Result<Entity>> getEntityById(String id);
  Future<Result<Entity>> createEntity(CreateEntityRequest request);
  Future<Result<Entity>> updateEntity(String id, UpdateEntityRequest request);
  Future<Result<void>> deleteEntity(String id);
}

// Implementation
class EntityRepositoryImpl implements EntityRepository {
  final NetworkService _networkService;
  
  EntityRepositoryImpl(this._networkService);
  
  @override
  Future<Result<List<Entity>>> getEntities() async {
    try {
      final response = await _networkService.get('/entities');
      final entities = (response.data as List)
          .map((json) => Entity.fromJson(json))
          .toList();
      return Success(entities);
    } catch (e) {
      return Failure(e.toString());
    }
  }
}
```

### UseCase Pattern
```dart
class GetEntitiesUseCase {
  final EntityRepository _repository;
  
  GetEntitiesUseCase(this._repository);
  
  Future<Result<List<Entity>>> call() async {
    return await _repository.getEntities();
  }
}
```

## 📊 Data Model Standards

### Use JsonSerializable (Preferred) or Freezed (Alternative)
```dart
// With JsonSerializable
@JsonSerializable()
class Entity extends Equatable {
  final String id;
  final String name;
  final DateTime createdAt;
  
  const Entity({
    required this.id,
    required this.name,
    required this.createdAt,
  });
  
  factory Entity.fromJson(Map<String, dynamic> json) => _$EntityFromJson(json);
  Map<String, dynamic> toJson() => _$EntityToJson(this);
  
  @override
  List<Object> get props => [id, name, createdAt];
}
```

## 🔗 Dependency Injection

### Service Locator Setup
```dart
// core/di/service_locator.dart
final getIt = GetIt.instance;

void setupServiceLocator() {
  // Core services
  getIt.registerLazySingleton<NetworkService>(() => HttpNetworkService());
  
  // Feature-specific registration
  setupAuthDI();
  setupCategoriesDI();
}

// features/feature/feature_di.dart
void setupFeatureDI() {
  // Repositories
  getIt.registerLazySingleton<FeatureRepository>(
    () => FeatureRepositoryImpl(getIt<NetworkService>()),
  );
  
  // Use Cases
  getIt.registerLazySingleton(() => GetEntitiesUseCase(getIt()));
  
  // Cubits (Factory for multiple instances)
  getIt.registerFactory(() => FeatureCubit(getIt()));
}
```

## 🎨 UI Architecture

### Atomic Design Pattern


### View Layer Rules
- **No Business Logic**: Views only handle presentation
- **BlocBuilder/BlocListener**: Use appropriate bloc widgets
- **Atomic Components**: Break down complex UIs into reusable pieces
- **Responsive Design**: Handle different screen sizes

## 🧪 Testing Standards

### Test Structure
```
test/
├── features/
│   └── {feature}/
│       ├── bloc/
│       │   ├── {feature}_cubit_test.dart
│       │   └── {feature}_cubit_test.mocks.dart
│       └── model/
│           ├── repositories/
│           │   ├── {feature}_repository_impl_test.dart
│           │   └── {feature}_repository_impl_test.mocks.dart
│           └── usecases/
│               ├── {usecase}_test.dart
│               └── {usecase}_test.mocks.dart
└── core/
    └── network/
        └── network_service_test.dart
```

### Testing Tools & Patterns
- **Mock Generation**: Use `@GenerateMocks` with mockito
- **Cubit Testing**: Use `bloc_test` package
- **Test Structure**: Arrange, Act, Assert pattern
- **Coverage**: Aim for high coverage on business logic
- **Widget Tests**: Always skip widget tests in development (focus on unit and integration tests)

## 🚫 Architecture Violations to Avoid

### Forbidden Patterns
- ❌ Business logic in UI widgets
- ❌ Direct API calls from Cubits
- ❌ Using Freezed for Cubit states
- ❌ Layer-first folder structure
- ❌ God classes or files
- ❌ Mixed annotation libraries (stick to one: JsonSerializable OR Freezed)
- ❌ Creating unnecessary abstractions
- ❌ Manual mock creation (use code generation)
- ❌ Widget tests (always skip widget tests in development)
- ❌ Should not use a usecase inside another use case
- ❌ Should not use a repository inside another repository
- ❌ Should not use a cubit inside another cubit

### Required Patterns
- ✅ Repository pattern for data access
- ✅ UseCase pattern for complex business logic
- ✅ Result wrapper for error handling
- ✅ Dependency injection for all dependencies
- ✅ Cubit for state management (Bloc only when needed)
- ✅ Feature-first folder organization
- ✅ Atomic design for UI components

## 🔄 Code Generation Commands

```bash
# Generate JSON serialization
dart run build_runner build --delete-conflicting-outputs

# Generate mocks for testing
dart run build_runner build --delete-conflicting-outputs

# Watch mode for development
dart run build_runner watch --delete-conflicting-outputs
```

---


### 🚫 Anti-Patterns to Avoid

- ❌ Embedding business logic inside UI (e.g., calling `cubit.someMethod()` inside `build`)
- ❌ Accessing Bloc/Cubit directly in deep nested widgets
- ❌ Deep widget trees in `*_page.dart` — extract into views
- ❌ Creating unnecessary atom/molecule folders just to match theory
- ❌ Rewriting reusable widgets for each feature (reuse via `core/widgets`)
- ❌ Using `Freezed` for Cubit states (use `Equatable` instead)
- ❌ Manual Cubit or Repository instantiation (use DI)

---

This structure enables:

- **Consistency** across all features
- **High reusability** via core widgets
- **Clear separation** of layout (views) and composition (widgets)
- **Clean testability** at every layer

Use this UI pattern as a strict convention for all current and future Flutter projects.

globs:
all projects
alwaysApply: true
---
